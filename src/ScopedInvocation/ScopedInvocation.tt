﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".Generated.cs" #>

<# const int maxTypes = 3; #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. 
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using Microsoft.Extensions.Logging;

namespace ScopedInvocation
{
<#
  for(var i = 1; i <= maxTypes; i++)
  {
    var allTs = string.Join(", ", Enumerable.Range(1, i).Select(x => "T" + x));
    var allServices = string.Join(", ", Enumerable.Range(1, i).Select(x => "s.GetRequiredService<T" + x + ">()"));
    var allConstraints = "        " + string.Join(Environment.NewLine + "        ", 
            Enumerable.Range(1, i).Select(x => "where T" + x + ": notnull"));
#>

    public interface IScopedInvocation<<#= allTs #>>
    {
        Task InvokeAsync(Func<<#= allTs #>, CancellationToken, Task> action,
            CancellationToken cancellationToken = default);

        Task InvokeAsync(Action<BaseScopedInvocationOptions>? options, Func<<#= allTs #>, CancellationToken, Task> action,
            CancellationToken cancellationToken = default);
    }

    internal class ScopedInvocation<<#= allTs #>> : ScopedInvocation, IScopedInvocation<<#= allTs #>>
<#=allConstraints#>
    {
        public ScopedInvocation(IScopedInvocationContextManager contextManager,
            IOptions<BaseScopedInvocationOptions>? defaultOptions,
            ILogger<BaseScopedInvocation<BaseScopedInvocationOptions>>? logger)
            : base(contextManager, defaultOptions, logger)
        {
        }

        public Task InvokeAsync(Func<<#= allTs #>, CancellationToken, Task> action,
            CancellationToken cancellationToken = default) =>
                InvokeAsync(options: null, action: action, cancellationToken);

        public Task InvokeAsync(Action<BaseScopedInvocationOptions>? options, Func<<#= allTs #>, CancellationToken, Task> action,
            CancellationToken cancellationToken = default) =>
                base.InvokeAsync(options, async s => await action(<#= allServices #>, cancellationToken).ConfigureAwait(false), cancellationToken);
        
    }   

<#
  }
#>

    public static class ServiceInvokerExtensions
    {
        public static IServiceCollection AddScopedInvocationGenerics(this IServiceCollection services)
        {
<#
  for(var i = 1; i <= maxTypes; i++)
  {
      var allOpenGenericTypes = "".PadLeft(i-1, ',');
#>
            services.AddTransient(typeof(IScopedInvocation<<#=allOpenGenericTypes#>>), typeof(ScopedInvocation<<#=allOpenGenericTypes#>>));
<#
  }
#>
            return services;
        }
    }

}
